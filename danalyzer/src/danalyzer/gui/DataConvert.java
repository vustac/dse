/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package danalyzer.gui;

import danalyzer.executor.ExecWrapper;
import danalyzer.executor.Value;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;

/**
 *
 * @author dmcd2356
 */
public class DataConvert {
  // this limits the max debug message length generated by valueToString and cleanStringValue 
  private static final int MAX_MESSAGE_LEN = 150;
  
  private static String getDotFormatType(String type) {
    if (type == null) {
      return null;
    }
    
    // trim leading "L" and trailing ";" from Object types
    if (type.startsWith("L")) {
      type = type.substring(1);
    }
    if (type.endsWith(";")) {
      type = type.substring(0, type.length() - 1);
    }

    return type.replace("/", ".");
  }
  
  /**
   * This handles the display of a primitive array.
   * 
   * NOTE: THIS IS INTENDED ONLY FOR DEBUG DISPLAY PURPOSES AS IT ACTUALLY HANDLES BOTH
   *       PRIMITIVES AND BOXED-PRIMITIVES
   * 
   * @param val  - the primitive array to examine
   * @param clz  - the class of the elements
   * @return a String that defines the type of data and its contents
   */
  private static String primArrayToString(Value val, String clz) {
    String valstr;
    int length;
    switch (clz) {
      // string arrays (not primitive type, but useful to get the info for it)
      case "[Ljava.lang.String":
        valstr = Arrays.toString((String[])val.getValue());
        length = ((String[])val.getValue()).length;
        break;

      // boxed primitive arrays
      case "[Ljava.lang.Boolean":
        valstr = Arrays.toString((Boolean[])val.getValue());
        length = ((Boolean[])val.getValue()).length;
        break;
      case "[Ljava.lang.Char":
        valstr = Arrays.toString((Character[])val.getValue());
        length = ((Character[])val.getValue()).length;
        break;
      case "[Ljava.lang.Byte":
        valstr = Arrays.toString((Byte[])val.getValue());
        length = ((Byte[])val.getValue()).length;
        break;
      case "[Ljava.lang.Short":
        valstr = Arrays.toString((Short[])val.getValue());
        length = ((Short[])val.getValue()).length;
        break;
      case "[Ljava.lang.Integer":
        valstr = Arrays.toString((Integer[])val.getValue());
        length = ((Integer[])val.getValue()).length;
        break;
      case "[Ljava.lang.Long":
        valstr = Arrays.toString((Long[])val.getValue());
        length = ((Long[])val.getValue()).length;
        break;
      case "[Ljava.lang.Float":
        valstr = Arrays.toString((Float[])val.getValue());
        length = ((Float[])val.getValue()).length;
        break;
      case "[Ljava.lang.Double":
        valstr = Arrays.toString((Double[])val.getValue());
        length = ((Double[])val.getValue()).length;
        break;

      // primitive arrays
      case "[Z":
        valstr = Arrays.toString((boolean[])val.getValue());
        length = ((boolean[])val.getValue()).length;
        break;
      case "[C":
        valstr = Arrays.toString((char[])val.getValue());
        length = ((char[])val.getValue()).length;
        break;
      case "[B":
        valstr = Arrays.toString((byte[])val.getValue());
        length = ((byte[])val.getValue()).length;
        break;
      case "[S":
        valstr = Arrays.toString((short[])val.getValue());
        length = ((short[])val.getValue()).length;
        break;
      case "[I":
        valstr = Arrays.toString((int[])val.getValue());
        length = ((Integer[])val.getValue()).length;
        break;
      case "[J":
        valstr = Arrays.toString((long[])val.getValue());
        length = ((long[])val.getValue()).length;
        break;
      case "[F":
        valstr = Arrays.toString((float[])val.getValue());
        length = ((float[])val.getValue()).length;
        break;
      case "[D":
        valstr = Arrays.toString((double[])val.getValue());
        length = ((double[])val.getValue()).length;
        break;
      default:
        return "";
    }

    return "length=" + length + ", value=" + valstr;
  }

  /**
   * returns the type of object passed
   * 
   * NOTE: THIS METHOD USES REFLECTION TO FIND THE CLASS OF THE OBJECT PASSED!
   * 
   * @param value - the object to examine
   * @return the class type of the object
   */
  public static String getClassType(Object value) {
    if (value == null) {
      return "java.lang.Object";
    }
    String clstype = getDotFormatType(value.getClass().getName());
    return clstype;
  }

  /**
   * converts a boxed-primitive data type to its corresponding primitive type
   * 
   * @param type - the primitive type
   * @return the corresponding data type
   */
  public static String getPrimitiveDataType(String type) {
    if (type == null) {
      return null;
    }
    type = getDotFormatType(type);
    switch (type) {
      case "java.lang.Boolean":
        return "Z";
      case "java.lang.Char":
        return "C";
      case "java.lang.Byte":
        return "B";
      case "java.lang.Short":
        return "S";
      case "java.lang.Integer":
        return "I";
      case "java.lang.Long":
        return "J";
      case "java.lang.Float":
        return "F";
      case "java.lang.Double":
        return "D";
      default:
        break;
    }
    return null;
  }

  /**
   * determines the Value.type flag settings for a given data class.
   * 
   * @param type - the data class to process (handles arrays, long and short data formats,
   *               and '/' or '.' class name separators.
   * @return the Value.type flag bits that correspond to the specified data type
   */
  public static int getValueDataType(String type) {
    if (type == null || type.isEmpty()) {
      return 0;
    }

    int vtype = 0;
    type = getDotFormatType(type);

    // check for array and multi-array types
    if (type.startsWith("[")) {
      if (type.startsWith("[[")) {
        vtype = Value.MARY;
      } else {
        vtype = Value.ARY;
      }
      type = type.substring(type.lastIndexOf("[")+1);
    }

    switch (type) {
      case "Z":
        return vtype + Value.BLN;
      case "C":
        return vtype + Value.CHR;
      case "B":
        return vtype + Value.INT8;
      case "S":
        return vtype + Value.INT16;
      case "I":
        return vtype + Value.INT32;
      case "J":
        return vtype + Value.INT64;
      case "F":
        return vtype + Value.FLT;
      case "D":
        return vtype + Value.DBL;
      case "java.lang.String":
        return vtype + Value.STR;
      default:
        break;
    }
    return vtype + Value.REF;
  }
  
  /**
   * this simply returns a String consisting of all of the Value.type flag settings
   * (used only for debug output).
   * 
   * @param vtype - the Value.type entry
   * @return the string indicating the flag bits set
   */
  public static String showValueDataType(int vtype) {
    String vstr = "";
    if (vtype == 0) {
      return "---";
    }
    if ((vtype & Value.SYM) != 0) {
      vstr += "SYM ";
    }
    if ((vtype & Value.ARY) != 0) {
      vstr += "ARY ";
    }
    if ((vtype & Value.MARY) != 0) {
      vstr += "MARY ";
    }
    if ((vtype & Value.BLN) != 0) {
      vstr += "BLN ";
    }
    if ((vtype & Value.CHR) != 0) {
      vstr += "CHR ";
    }
    if ((vtype & Value.INT8) != 0) {
      vstr += "INT8 ";
    }
    if ((vtype & Value.INT16) != 0) {
      vstr += "INT16 ";
    }
    if ((vtype & Value.INT32) != 0) {
      vstr += "INT32";
    }
    if ((vtype & Value.INT64) != 0) {
      vstr += "INT64 ";
    }
    if ((vtype & Value.FLT) != 0) {
      vstr += "FLT ";
    }
    if ((vtype & Value.DBL) != 0) {
      vstr += "DBL ";
    }
    if ((vtype & Value.STR) != 0) {
      vstr += "STR ";
    }
    if ((vtype & Value.REF) != 0) {
      vstr += "REF ";
    }
    return vstr.trim();
  }
  
  /**
   * returns the value for String and boxed types and class type for all others
   * (used only for debug output).
   * 
   * NOTE: THIS METHOD USES REFLECTION TO FIND THE CLASS OF THE OBJECT PASSED!
   * 
   * @param value - the object to examine
   * @return the contents of or class type of the object
   */
  public static String getObjectValue(Object value) {
    if (value == null) {
      return "null";
    }
    String name = getClassType(value);
    switch (name) {
      case "java.lang.Integer":
        return ((Integer) value).toString();
      case "java.lang.Long":
        return ((Long) value).toString();
      case "java.lang.Byte":
        return ((Byte) value).toString();
      case "java.lang.Short":
        return ((Short) value).toString();
      case "java.lang.Float":
        return ((Float) value).toString();
      case "java.lang.Double":
        return ((Double) value).toString();
      case "java.lang.String":
        return cleanStringValue((String) value);
      default:
        break;
    }
    return name;
  }
  
  /**
   * eliminates non-printable chars from a string (replaced by ~ char) and limits the
   * max length of the string
   * (used only for debug output).
   * 
   * @param valstr - the string value to adjust
   * @return the cleaned up string value
   */
  public static String cleanStringValue(String valstr) {
    if (valstr != null && !valstr.isEmpty()) {
      int strlen = valstr.length() > MAX_MESSAGE_LEN ? MAX_MESSAGE_LEN : valstr.length();
      // replace all non-printabe chars with '~'
      valstr = valstr.substring(0, strlen).replaceAll("[^\\x20-\\x7F]", "~");
      //valstr = valstr.substring(0, strlen).replace('\r', '.').replace('\n', '.');
    }
    return valstr;
  }
  
  /**
   * return the string representation of the specified Value object as best as it can
   * (used only for debug output).
   * 
   * NOTE: THIS METHOD USES REFLECTION TO FIND THE CLASS OF THE OBJECT PASSED!
   * 
   * @param val - the Value entity to examine
   * @return a String expression of the contents of val
   */
  public static String valueToString(Value val) {
    // eliminate the obvious
    if (val == null) {
      return "type=<none>, class=<none>, value=<null>";
    } else if (!getClassType(val).equals("danalyzer.executor.Value")) {
      return "type = " + getClassType(val);
    } else if (val.getValue() == null) {
      return "type=" + showValueDataType(val.getType()) + ", class=java.lang.Object, value=<null>";
    }

    Object obj = val.getValue();
    String valstr = "";
    String refstr = "";
    String clz = getClassType(obj);
    int type = val.getType();

    // first, check if it is an array
    Value[] combo = null;
    if (val.isType(Value.ARY)) {
      // first, get the combo[] value, which can also be a reference to the combo value
      if (clz.equals("java.lang.Integer")) {
        // Integer means this is a reference to a combo array
        int refCnt = (Integer) obj;
        combo = (Value[]) ExecWrapper.getComboValue(refCnt);
        valstr = "(combo-ref) ";
        refstr = ", refCnt=" + refCnt;
      } else if (clz.equals("[Ldanalyzer.executor.Value")) {
        // verify this is a valid combo array
        combo = (Value[]) obj;
        valstr = "(combo) ";
      }
      if (combo != null && combo[0] != null) {
        // now there are 2 types: a Value array has an array of Value types in combo[0] and a Value
        // containing the size in combo[1]. Otherwise combo[0] is a primitive array and combo[1] is null.
        clz = getClassType(combo[0].getValue());
        type = combo[0].getType() | Value.ARY;

        if (clz.startsWith("[[")) {
          // don't even bother expanding multi-dimensional arrays
          valstr = "(multi-dim array)";
        } else if (val.isType(Value.SYM) || combo[0].isType(Value.SYM)) {
          // same with symbolics - just indicate it is symbolic
          valstr += "(symbolic)";
        } else if (combo[1] == null) {
          // if length is null, this is a combo of primitives
          valstr = "(combo-prim) " + primArrayToString(combo[0], clz);
        } else {
          // this is a combo array type: peer into it to get array data
          Value[] array = (Value[]) combo[0].getValue();
          int length = (int) combo[1].getValue();

          if (array == null || length <= 0) {
            valstr += "value=null";
          } else {
            valstr += "length=" + length + ", value=";
            String clz2 = getClassType(array);
            if (!clz2.contains("Ldanalyzer.executor.Value")) {
              // invalid element type in array
              valstr += "element type = " + clz2;
            } else {
              String elclz = "unknown";
              for (int ix = 0; ix < length && ix < 8; ix++) {
                if (array[ix] != null) {
                  elclz = showValueDataType(array[ix].getType()); // getClassType(array[0].getValue());
                  break;
                }
              }

              clz = "Value[" + elclz + "]";
              valstr += "[";
              for (int ix = 0; ix < length && ix < 10; ix++) {
                if (ix > 0) {
                  valstr += ", ";
                }
                if (array[ix] == null) {
                  valstr += "null";
                } else {
                  valstr += array[ix].toString();
                }
              }
              if (length > 10) {
                valstr += "...";
              }
              valstr += "]";
            }
          }
        }
      }
    } else if (val.isType(Value.MARY)) {
      int refCnt = (Integer) obj;
      ExecWrapper.MultiArrayInfo info = ExecWrapper.getMultiArrayInfo(refCnt);
      ArrayList<Integer> dimensions = ExecWrapper.getMultiArraySizes(refCnt);
      valstr = "(multi-dim array)";
      refstr = ", refCnt=" + refCnt;
      if (info != null) {
        valstr += " type " + showValueDataType(info.type) + ", arrRef " + info.arrayRef + ", dim " + info.dim + ", off " + info.offset;
      }
      if (dimensions != null) {
        valstr += ", size " + dimensions.toString();
      }
    } else if (type == Value.REF && clz.equals("java.lang.Integer")) {
      // reference object entry
      clz = "Map";
      int refCnt = (int) obj;
      refstr = ", refCnt=" + refCnt;
      Map<String, Value> ref = ExecWrapper.getReferenceObject(refCnt);
      valstr = "value=" + (ref == null ? "null" : ref.toString());
    } else if (clz.equals("Ldanalyzer.executor.Value")) {
      // Normal Value entry
      valstr = "value=" + ((Value) obj).toString();
    } else if (clz.equals("java.util.HashMap")) {
      valstr = "value=" + obj;
    } else if (!val.isType(Value.REF)) {
      // might be dangerous to display reference types
      valstr = "value=" + obj;
    }
    
    // generate response string
    valstr = cleanStringValue(valstr);
    String response = "type=" + showValueDataType(type) + refstr + ", class=" + clz + ", " + valstr;
    if (response.length() > MAX_MESSAGE_LEN) {
      response = response.substring(0, MAX_MESSAGE_LEN) + "...";
    }
    return response;
  }

}
